/**
 * IfcValidator.js
 * 
 * Standalone validator for IFC4 files generated by ISYBAU Parser.
 * Checks:
 * 1. Referential Integrity (All #ID refs exist)
 * 2. Syntax (No [object Object], NaN, undefined)
 * 3. Schema Compliance (Basic param counts for key entities)
 */

export class IfcValidator {
    constructor() {
        this.errors = [];
        this.idMap = new Set();
        this.lines = [];
    }

    validate(ifcContent) {
        this.errors = [];
        this.idMap.clear();
        this.lines = ifcContent.split('\n');

        // 1. First Pass: Collect IDs
        this.lines.forEach((line, index) => {
            const trimmed = line.trim();
            if (trimmed.startsWith('#')) {
                const match = trimmed.match(/^#(\d+)=/);
                if (match) {
                    this.idMap.add(match[1]);
                }
            }
        });

        // 2. Second Pass: Check Integrity & Content
        this.lines.forEach((line, index) => {
            if (!line.trim()) return;
            this.checkSyntax(line, index + 1);
            this.checkReferences(line, index + 1);
            this.checkSchema(line, index + 1);
        });

        // 3. Final Pass: Check Geometry Existence
        const geometryCount = this.checkGeometryPresence();
        if (geometryCount === 0 && this.idMap.size > 0) {
            this.errors.push({ line: 0, msg: 'CRITICAL: No Geometry found (No IFCEXTRUDEDAREASOLID or BREP)' });
        }

        return {
            valid: this.errors.length === 0,
            errors: this.errors,
            totalLines: this.lines.length,
            entityCount: this.idMap.size,
            geometryCount: geometryCount
        };
    }

    checkGeometryPresence() {
        let count = 0;
        this.lines.forEach(line => {
            if (line.includes('IFCEXTRUDEDAREASOLID') ||
                line.includes('IFCFACEBASEDSURFACEMODEL') ||
                line.includes('IFCSHELLBASEDSURFACEMODEL') ||
                line.includes('IFCTRIANGULATEDFACESET')) {
                count++;
            }
        });
        return count;
    }

    report(res) {
        if (res.valid) {
            console.log(`✅ IFC Validation Passed! (${res.entityCount} entities, ${res.geometryCount} geometries)`);
        } else {
            console.error(`❌ IFC Validation Failed with ${res.errors.length} errors:`);
            res.errors.slice(0, 10).forEach(e => console.error(`   Line ${e.line}: ${e.msg}`));
            if (res.errors.length > 10) console.error(`   ... and ${res.errors.length - 10} more.`);
        }
    }

    // --- CHECKS ---

    checkSyntax(line, lineNum) {
        if (line.includes('[object Object]')) {
            this.errors.push({ line: lineNum, msg: 'Serialization Error: [object Object] found' });
        }
        if (line.includes('undefined')) {
            this.errors.push({ line: lineNum, msg: 'Serialization Error: "undefined" found' });
        }
        if (line.includes('NaN')) {
            this.errors.push({ line: lineNum, msg: 'Serialization Error: "NaN" found' });
        }
    }

    checkReferences(line, lineNum) {
        // Find all #123 patterns NOT at start of line
        const matches = line.matchAll(/[=(,]\s*#(\d+)/g);
        for (const m of matches) {
            const refId = m[1];
            if (!this.idMap.has(refId)) {
                this.errors.push({ line: lineNum, msg: `Broken Reference: #${refId} does not exist` });
            }
        }
    }

    checkSchema(line, lineNum) {
        // Example: IFCEXTRUDEDAREASOLID(#1,#2,#3,1.0) -> 4 args
        if (line.includes('IFCEXTRUDEDAREASOLID')) {
            const content = this.extractArgs(line);
            if (!content) return;
            // Args are comma separated, but nested parens exist. Simple check:
            // This is a naive heuristic for headless usage without full parser.
            // We just check if it looks roughly right.
            if (line.match(/IFCEXTRUDEDAREASOLID\([^)]+\)/)) {
                // Check for duplicate arguments pattern we saw before
                // e.g. (#27,#24,#28,#24,#28,0.9870) which has 6 args instead of 4
                const parts = content.split(',');
                if (parts.length > 4) {
                    this.errors.push({ line: lineNum, msg: `Schema Violation: IFCEXTRUDEDAREASOLID should have 4 args, found ${parts.length}` });
                }
            }
        }

        // Check Profile Defs for nested Entities
        if (line.includes('IFCCIRCLEPROFILEDEF')) {
            if (line.includes('IFCCIRCLE(')) {
                this.errors.push({ line: lineNum, msg: `Schema Violation: IFCCIRCLEPROFILEDEF contains disallowed nested entity IFCCIRCLE` });
            }
        }
        if (line.includes('IFCRECTANGLEPROFILEDEF')) {
            if (line.includes('IFCRECTANGLE(')) {
                this.errors.push({ line: lineNum, msg: `Schema Violation: IFCRECTANGLEPROFILEDEF contains disallowed nested entity IFCRECTANGLE` });
            }
        }
    }

    extractArgs(line) {
        const start = line.indexOf('(');
        const end = line.lastIndexOf(')');
        if (start === -1 || end === -1) return null;
        return line.substring(start + 1, end);
    }
}
